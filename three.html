<!DOCTYPE html>
<html>
<head>
    <title>Three.js Hello World - 藍色旋轉立方體</title>
    <style>
        body { margin: 0; }
        canvas { display: block; } /* 確保畫布沒有額外的邊距或間隙 */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <script>
        // --- 1. 初始化基本元素 ---

        // 1.1 創建場景 (Scene)
        const scene = new THREE.Scene();

        // 1.2 創建攝影機 (Camera)
        // 參數：視角(FOV)、長寬比、近裁面、遠裁面
        const camera = new THREE.PerspectiveCamera(
            75, // 視角 (Field of View)
            window.innerWidth / window.innerHeight, // 長寬比 (Aspect Ratio)
            0.1, // 近裁面 (Near clipping plane)
            1000 // 遠裁面 (Far clipping plane)
        );

        // 1.3 創建渲染器 (Renderer)
        const renderer = new THREE.WebGLRenderer();
        // 設定渲染器尺寸為整個瀏覽器窗口
        renderer.setSize(window.innerWidth, window.innerHeight);
        // 將渲染器的 DOM 元素（Canvas）添加到 HTML 文件的 body 中
        document.body.appendChild(renderer.domElement);

        // --- 2. 創建物體 (Mesh) ---

        // 2.1 創建幾何體 (Geometry) - 寬、高、深皆為 1 的立方體
        const geometry = new THREE.BoxGeometry(1, 1, 1);

        // 2.2 創建材質 (Material) - 設置為藍色，使用基本材質 (不受光線影響)
        const material = new THREE.MeshBasicMaterial({ color: 0x0000ff });

        // 2.3 創建網格 (Mesh) - 將幾何體和材質結合
        const cube = new THREE.Mesh(geometry, material);

        
        // 2.4 將立方體加入場景
        scene.add(cube);

        // 2.5 設定攝影機位置，使其能看到立方體 (沿 Z 軸往後退 5 單位)
        camera.position.z = 5;

        // --- 3. 動畫渲染循環 (Animation Loop) ---

        // 建立一個函式來不斷重複繪製場景
        function animate() {
            // 請求瀏覽器在下次畫面重繪時執行 animate 函式
            // 這是實現動畫最有效率的方法
            requestAnimationFrame(animate);

            // 讓立方體在每一幀都稍微旋轉
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;

            // 使用渲染器繪製場景
            renderer.render(scene, camera);
        }

        // 啟動動畫循環
        animate();

        // --- 4. 響應式調整 (Optional: 確保視窗大小改變時能正確縮放) ---
        window.addEventListener('resize', () => {
            // 更新攝影機的長寬比
            camera.aspect = window.innerWidth / window.innerHeight;
            // 更新攝影機的投影矩陣
            camera.updateProjectionMatrix();
            // 更新渲染器的尺寸
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>